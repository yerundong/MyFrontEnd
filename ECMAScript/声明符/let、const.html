<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			// [let]
			// var是全局的，let是块级的
			// let声明的变量只在它所在的【代码块】有效
			// var将逐渐弃用，以let代替定义变量

			// [const]
			// const声明一个只读的常量，不可修改,修改会报错
			const a1 = 1;
			// a1 = 1;//  报错
			// a1 = 2;//  报错

			// const对[基本类型]数据要求是[值]不得改动，对[引用类型]数据要求是[引用地址]不得改动
			// 由于对引用类型数据（对象、数组）进行[成员的增删改查]不会影响其[引用地址]，所以允许改动，不会报错
			const obj1 = {
				a:1
			}
			obj1.a = 2;// 不报错
			// console.log(obj1);// {a:2}

			const arr1 = [1,2];
			arr1.push(3);// 不报错
			// arr1 = [1,2,3];// 报错 引用地址发生改变
			// console.log(arr1);// [1, 2, 3]

			// const声明与赋值需要同时进行，不能留着后面赋值，否则会报错。
			// const a2;// 报错

			// 不过可以赋值给undefined
			const a3 = undefined;
			// a3 = undefined;// 报错
			// a3 = null;// 报错
			// a3 = 123;// 报错

			const a4 = null;
			// a4 = null;// 报错
			// a4 = undefined;// 报错


			// ------------------------------------------------------------?????????????????👇
			// demo1:
			// var声明的i是全局变量,且只有一个，每次循环都会改变这个全局的i值
			// 循环内被赋给数组a的function在运行时，会通过【闭包】读到这同一个变量i，
			// 导致最后输出的是最后一轮的i的值，也就是10。
			var arrFn = [];
			for(var i = 0; i < 10; i++) {
				arrFn[i] = function() {
					console.log(i);
				};
			}
			// arrFn[5](); // 10	
			
			// demo2:
			// let声明的i是局部变量，当前的i只在【本轮循环有效】，所以每一次循环的i其实都是一个【新的变量】
			// 所以最后输出的是5
			for(let i = 0; i < 10; i++) {
				arrFn[i] = function() {
					console.log(i);
				};
			}
			// arrFn[5](); // 5
		</script>
		
	</body>
</html>
