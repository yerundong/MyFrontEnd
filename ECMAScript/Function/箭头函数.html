<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>箭头函数</title>
</head>

<body>
	<script type="text/javascript">
		// [单个参数写法]
		// v => v+1; v是参数，返回v+1
		let fn = v => v + 1;
		// 相当于于：
		// let fn = function (v) {
		// 	return v + 1;
		// }
		// console.log(fn(9));// 10

		// [无参或多个参数写法]
		let py = () => 998;
		// console.log(py());// 998

		let pt = (m, l, b) => m + l + b;
		// console.log(pt('c','n','d'));// cnd

		// [多于一条语句写法]
		// 使用return返回
		// 大括号被解释为代码块
		let uj = (g, o) => {
			let all = g + o;
			let res = all%2;
			return all+res;
		}
		// console.log(uj(5,9));// 14

		// 如果返回一个[对象]，必须在对象外面加上[小括号]，否则会报错，因为js解析器会把{}看成代码块
		let baga = (k, j) => ({ name: k, age: j })
		// console.log(baga('ah',99));// 14

		// 如果箭头函数[只有一行语句，且不需要返回值]，则使用void
		// 无void只是单纯的执行uj，若去掉void，则会返回uj的值
		let lj = () => void uj(7, 8);
		// console.log(lj());

		// 与[解构赋值]一起使用
		// 求和
		let getSum = ([...vals]) => {
			let sum = 0;
			for (let v of vals) {
				sum += v
			}
			return sum
		}
		// console.log(getSum([1,23,65,54,65,6,45,65,1]));

		// [this指向]
		// 在箭头函数中，this指向是固定的,永远[指向函数定义时所在的对象]
		// 而function定义的函数this是可变的，[指向函数运行时所在的对象]
		// 箭头函数里面根本没有自己的this，而是引用外层的this
		// 由于箭头函数没有自己的this，所以也就不能用call()、apply()、bind()方法去改变this的指向。
		let zaza = () => { console.log(this) }
		let papa = function () {
			console.log(this)
		}
		let obj1 = {
			fn1:zaza,
			fn2:papa,
			fn3:()=>{
				console.log(this)
			},
			fn4(){
				console.log(this)
			},
		}
		obj1.fn1();// window
		obj1.fn2();// obj1
		obj1.fn3();// window
		obj1.fn4();// obj1
		// call、apply、bind对它无效
		zaza.call(obj1);// window
		zaza.apply(obj1);// window
		zaza.bind(obj1)();// window

		// 由于箭头函数没有自己的this，所以不可当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
		let Fl = (a) => a;
		// new Fl();// 报错
		
		// 箭头函数不可以使用[arguments对象],可以用rest参数代替
		// 不可以使用yield命令，因此箭头函数不能用作[Generator函数]。
	</script>
</body>
</html>