<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // [generator]（生成器）
        // Generator函数是ES6提供的一种[异步编程]解决方案，语法行为与传统函数完全不同
        // 可以把Generator函数理解成是一个[状态机]，封装了[多个内部状态]
        // Generator函数类型是function类型，本质上也是函数
        // 定义一个Generator函数有两个特征：
        // 使用关键字function，且在function与函数名之间加一个星号（*）
        // 函数体内部使用yield表达式，定义不同的[内部状态]
        function* gen1() {
            yield 'a';
            yield 'b';
            return 'c';
        }
        // console.log(typeof gen1);// function
        
        // Generator函数[调用方式]与普通函数一样，不同是Generator函数并不执行
        // 调用Generator函数会返回一个遍历器对象(iterator)，可以此依次遍历Generator函数内部的每一个状态
        // 所以，Generator函数除了是状态机，还是一个[遍历器对象生成函数]
        let gen1_iterator = gen1();
        for(let val of gen1_iterator){
            // console.log(val);// a b
        }

        // Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态
        // console.log(gen1_iterator.next());
        // console.log(gen1_iterator.next());
        // console.log(gen1_iterator.next());

        // 作为对象下方法的Generator函数
        // 这两种写法都是合法的
        const obj1 = {
            gen1: function*(){
                yield 'val1';
            },
            *gen2(){
                yield 'val2';
            },
        }
        const obj1_gen1_iter = obj1.gen1();
        const obj1_gen2_iter = obj1.gen2();
        // console.log(obj1_gen1_iter.next());
        // console.log(obj1_gen2_iter.next());
    </script>
</body>

</html>