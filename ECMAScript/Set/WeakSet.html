<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>
        // WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别:
        // 第一：WeakSet的成员只能是[对象类型]，而不能是其他类型的值，否则报错   
        // 第二，WeakSet中的对象都是[弱引用]，即垃圾回收机制不考虑WeakSet对该对象的引用，不会产生内存泄漏
        // 即若其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中
        // 由于WeakSet内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，
        // 而垃圾回收机制何时运行是不可预测的，因此ES6规定WeakSet[不可遍历]
        // WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏
        // new WeakSet([1,2,3]); // 报错
        // new WeakSet([null]); // 报错
        // new WeakSet(); // 不报错
        // new WeakSet([]); // 不报错

        let obj1 = { a: 1 };
        const wset1 = new WeakSet([obj1]);
        // console.log(wset1);

        // 没有iterator接口，不可遍历
        // console.log(wset1[Symbol.iterator]);// undefined 

        // 没有size，不可遍历
        // console.log(wset1.size);// undefined 

        // 没有forEach
        // console.log(wset1.forEach);// undefined 

        // 实例下有add()、delete()、has()方法，用法与set的一致，参考set文件
        let obj2 = { b: 2 };
        wset1.add(obj2);
        // console.log(wset1);

        const hasResult = wset1.has(obj2);
        // console.log(true);// true

        const deletResult = wset1.delete(obj2);
        // console.log(wset1);
        // console.log(deletResult);// true

    </script>
</body>

</html>